---

name: Классы
theory: |

  Типизация классов в TypeScript добавляет новый синтаксис определения классов, которого нет в JavaScript. Этот синтаксис существует только на уровне проверки типов. В результирующем коде он вырезается или заменяется. В этом уроке мы изучим реализацию таких классов.

  ## Определение полей внутри класса

  Начнем с примера. Посмотрите на этот класс:

  ```typescript
  class Point {
    x: number;
    y: number;

    constructor(x: number, y: number) {
      this.x = x;
      this.y = y;
    }
  }

  const p = new Point(10, 20);
  console.log(p); // { x: 10, y: 20 }
  ```

  Здесь мы видим новый синтаксис, который описывает поля класса: `x` и `y`. Их описание обязательно, так как классы — это функции-конструкторы, а функции в TypeScript являются объектами.

  Перед тем как двигаться дальше, разберемся с понятием «поле класса».

  ## Поле класса

  Обычно в JavaScript все называют свойствами. А слово «поле» используют как синоним те, кто пришел из других языков. Но это не одно и тоже.

  Внутри класса мы определяем **поля** — это данные самого класса. А **свойство** — это то, с помощью чего мы взаимодействуем с объектом.

  Часто свойства и поля совпадают, но так происходит не всегда. Например, свойство может быть доступно только для чтения - геттером, который берет информацию из поля. Или свойство может быть доступно только для записи - сеттером, который устанавливает новое значение поля:

  ```typescript
  class Point {
    x: number;

    y: number;

    // Возвращаемый тип не указывается, так как это конструктор
    constructor(x: number, y: number) {
      this.x = x;
      this.y = y;
    }

    get inspect(): string {
      return `(${this.x}, ${this.y})`
    }
  }

  const p = new Point(2, 5);
  // Свойство есть, а поля такого нет
  console.log(p.inspect); // (2, 5)
  ```

  В примере мы определили геттер `inspect`, который возвращает строку с координатами точки. Это свойство доступно только для чтения, так как мы не определили сеттер.

  Поля могут быть инициализированы сразу при определении класса. Это удобно, когда конструктор не нужен или данные не зависят от его вызова — задаются статически внутри:

  ```typescript
  class Point {
    x = 0;

    y = 0;
  }

  const p = new Point();
  console.log(p); // { x: 0, y: 0 }
  ```

  Как и в случае обычных переменных, тип полей выводится автоматически во время их инициализации, поэтому указывать явный тип не обязательно.

instructions: |

  Реализуйте класс `CustomFile`, в конструктор которого передается объект с полями: `name` — именем файла, и `size` — размером в байтах. Внутри класса определите метод `toString()`, который должен вернуть форматированную строку в формате `<file-name> (<size> bytes)`.

  ```typescript
  const file = new CustomFile({ name: 'open-world.jpeg', size: 1000 });
  console.log(file.toString()); // open-world.jpeg (1000 bytes)
  ```

tips:
  - |
    [Официальная документация](https://www.typescriptlang.org/docs/handbook/2/classes.html)
