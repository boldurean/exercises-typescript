---

name: Дженерики (Функции)
theory: |

  Представим, что дженерики пропали из языка. Тогда произойдет дублирование кода. Придется описывать один и тот же алгоритм для разных типов данных много раз.
  
  Возьмем для примера функцию `last()`, возвращающую последний элемент массива. Ниже ее обобщенная версия:

  ```typescript
  function last<T>(coll: T[]): T {
    return coll[coll.length - 1];
  }
  ```

  Дженерики также могут использоваться в стрелочных функциях:
  
  ```typescript
  const last = <T>(coll: T[]): T => {
    return coll[coll.length - 1];
  };
  ```
  
  <!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

  Теперь попробуем реализовать то же поведение, но без применения дженериков. Для этого нам придется создать по одной функции для каждого типа. Причем имя функции должно быть уникальным:

  ```typescript
  function lastForNumberType(coll: number[]): number {
    return coll[coll.length - 1];
  }

  function lastForStringType(coll: string[]): string {
    return coll[coll.length - 1];
  }

  // Тут определения для всех остальных типов
  ```
  
  <!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

  Если типов несколько, то количество функций, которые нужно определить, будет определяться как произведение количества всех возможных типов на количество параметров типа.

  Реализация дженерика с помощью перегруженной функции упрощает задачу. Тогда не придется создавать новые имена:

  ```typescript
  function last(coll: number[]): number;
  function last(coll: string[]): string;
  // Тут определения для всех остальных типов

  function last(coll: any[]): any {
    return coll[coll.length - 1];
  }
  ```
  
  <!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

  В случае TypeScript даже не будет дублироваться логика, но это особенность именно TypeScript. В других статически типизированных языках придется дублировать и логику.

  Какой бы вариант реализации мы не выбрали, соблюдаются две вещи:

  * Значения, передаваемые во внутрь, никак не используются. Они только перекладываются из одного места в другое
  * Логика работы всегда остается одной и той же. Условные конструкции по типу данных отсутствуют

  В Computer Science свойство функции, позволяющее обрабатывать значения разных типов одним способом (используя один алгоритм), называется параметрическим полиморфизмом. То есть дженерики — это реализация параметрического полиморфизма в TypeScript.

  Параметрический полиморфизм играет важную роль в статически типизированных языках там, где приходится явно указывать типы у функций. Он есть почти во всех высокоуровневых статически типизированных языках. В Java и C# это тоже называется дженериками. В C++ используется названия шаблоны, но смысл от этого не меняется, хотя шаблоны в С++ — это больше, чем параметрический полиморфизм.

  В противовес статически типизированным языкам в языках с динамической типизацией, таких как JavaScript, Python, Ruby, PHP, дженерики не нужны. В подобных языках любой обобщенный алгоритм автоматически работает для всех типов данных.

instructions: |

  Реализуйте описание обощенного типа `MyArray`, который представляет аналог массива из JavaScript. Пример использования объекта этого типа:

  ```typescript
  const coll: MyArray<number> = ...;
  coll.push(1); // 1
  coll.push(10); // 2
  coll.push(99); // 3

  const newColl = coll.filter((value) => value % 2 == 0);
  console.log(newColl.items); // [10]
  ```

  Тип включает в себя два метода: [push()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push) и [filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter), совпадающие по сигнатуре с методами Array. Данные внутри должны храниться в свойстве `items`. Для `push()` примем соглашение, что метод принимает только один параметр. Игнорируйте остальные параметры.

tips:
  - |
    [Дженерики в TypeScript: разбираемся вместе](https://habr.com/ru/post/455473/)
  - |
    [Полиморфизм простыми словами](https://medium.com/devschacht/polymorphism-207d9f9cd78)
