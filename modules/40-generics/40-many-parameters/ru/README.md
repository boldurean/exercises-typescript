
Дженерики, как и обычные функции, могут иметь несколько параметров типа. В этом уроке мы разберем такие дженерики.

Принцип работы дженериков от количества параметров не меняется. Единственное, за чем нужно следить, это имена:

```typescript
type Double<T, U> = {
  first: T;
  second: U;
}

const value: Double<string, number> = {
  first: 'code-basics',
  second: 1,
}
```

<!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

## Вывод типа из аргументов функции

Представим, что нам нужно вызвать функцию с несколькими параметрами. Аргументы представлены дженериками.

Например, функция `join()` может быть описана следующим образом:

```typescript
function join<T, U>(coll1: (T | U)[], coll2: U[]): (T | U)[] {
  return coll1.concat(coll2);
};

join<number, string>([1, 2], ['one', 'two']); // [1, 2, 'one', 'two']
```

<!-- TODO - автору: не хватает описания кода - на что обратить внимание, или что тут сделали -->

Но TypeScript позволяет нам сделать это проще и не указывать типы для всех параметров:

```typescript
join([1, 2], ['one', 'two']); // [1, 2, 'one', 'two']
```

TypeScript сам выведет типы для параметров функции. Это называется выводом типа из аргументов функции. В данном случае TypeScript выведет типы `number` и `string` для параметров `T` и `U` соответственно.

В следующих уроках мы познакомимся со встроенными в TypeScript дженериками, у которых два параметра. В реальном же программировании такие дженерики часто встречаются в прикладном коде, например, в React.
